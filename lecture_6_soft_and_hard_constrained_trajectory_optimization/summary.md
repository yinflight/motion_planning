# 总结

## 1. Introduction

在第五节中介绍了使用minimum snap生成轨迹，在实验的过程中发现在生成轨迹时只会限制轨迹通过哪些waypoints，但是并不会限制轨迹本身的形状，所以如果情况复杂之后，轨迹很可能就会被规划到障碍物中。所以最基础的minimum snap framework适合生成光滑的轨迹，但是并不适合避障。

因此对于minimum snap轨迹生成算法可以进行如下两种改进方法：

- 给轨迹增加推力(软约束)，使得轨迹尽量朝着推力的方向收缩；
- 给轨迹增加约束条件(硬约束)，使得轨迹严格满足约束条件。

## 2. Hard-constrained Optimization

**多项式的轨迹硬约束**

硬约束方法是通过生成飞行走廊(flight corridor)，然后将多项式轨迹的waypoints牢牢地限制在飞行走廊的交集内。该方法相对于basic minimum snap有很大提升，但是还是不能完全保证轨迹完全是安全的。因此在生成出轨迹之后，还需要进行后验检测，对轨迹进行离散，然后检测是否超过飞行走廊的区域，如果超过再增加约束，然后重新优化。

很明显基于多项式的硬约束有一个很大的限制，就是需要迭代的去检测轨迹是否生成的正确和可行。

**贝塞尔(Bernstein)曲线轨迹硬约束**

由于多项式轨迹只能约束中间点不能约束轨迹的形状，而贝塞尔曲线却正好可以很容易的完成轨迹形状的约束。

重新考虑第五节中基于多项式的轨迹生成模型

首先，写出代价函数矩阵以及约束条件：
$$
\min 
\left[ 
\begin{matrix} 
p_1 \\ \vdots \\ p_M 
\end{matrix} 
\right]^T

\left[ 
\begin{matrix} 
Q_1 & 0 & 0 \\ 0  & \ddots & 0 \\  0 & 0 & Q_M
\end{matrix} 
\right]

\left[ 
\begin{matrix} 
p_1 \\ \vdots \\ p_M 
\end{matrix} 
\right]

\\
s.t.  A_{eq} 
\left[ 
\begin{matrix} 
p_1 \\ \vdots \\ p_M 
\end{matrix} 
\right] = d_{eq} \tag{0}
$$
式子（0）表示了对于有等式约束的情况下，轨迹生成的问题。

其中，

- $Q_j$表示每一段轨迹的二项式系数；

- $p_j$表示每一段轨迹对应的系数向量；

- $A_{eq}$表示约束条件的系数矩阵，其中包含了连续性约束和微分约束。对于约束条件更细致的表示如下：
  $$
  \left[ 
  \begin{matrix} 
  A_0 & \cdots & \cdots & 0 \\
  0 & A_1 & \cdots & 0 \\
  \vdots & \vdots & \ddots & \vdots \\
  0 & 0 & 0 & A_M \\
  A_0 & -A_1 & \cdots & 0 \\
  0 & A_1 & -A_2 & 0 \\
  \vdots & \vdots & \ddots & \vdots \\
  0 & 0 & A_{M-1} & -A_M
  \end{matrix} 
  \right] 
  \left[ 
  \begin{matrix} 
  p_1 \\ \vdots \\ p_M 
  \end{matrix} 
  \right]
  = 
  \left[ 
  \begin{matrix} 
  d_0 \\ d_1 \\ d_M \\ 0 \\  \vdots  \\ 0
  \end{matrix} 
  \right] \tag{1}
  $$

对于多项式曲线公式，可以转换成贝塞尔曲线的形式。

贝塞尔曲线：
$$
B_j(t) = c_j^0b_n^0(t)+c_j^1b_n^1(t)+\cdots+c_j^nb_n^n(t) = \sum_{i=0}^nc_j^ib_n^i(t) \tag{2}
$$
其中，

- $c_j^0$是控制点，它决定了轨迹的形状；
- $b_n^j(t)= C_n^it^i(1-t)^{n-i}$

如果（2）式的贝塞尔曲线公式进行合并转换，最终它将能转成多项式的形式。所以贝塞尔曲线其实就是一种形式比较特殊的多项式，那么贝塞尔曲线和多项式曲线之间必然存在一个转换关系。因此可以通过下式将多项式曲线和贝塞尔曲线联系起来：
$$
p=M\cdot c \tag{3}
$$
如果通过（3）式将（0）式转换成包含贝塞尔曲线的形式，那么可以以贝塞尔曲线为基础进行轨迹生成。

因此对于（0）式可以改写成如下形式：
$$
J_j(T) = c_j^T\cdot M^TQ_jM \cdot c_j = c^T\cdot Q_o \cdot c \tag{4}
$$
对于约束也同样的可以进行类似的改写：
$$
A_j \cdot M \cdot c_j = d_j \tag{5}
$$
最终，对于贝塞尔曲线的轨迹生成可以写成如下形式：
$$
\min c^T \cdot Q_o \cdot c \\
s.t. A_{eq} \cdot c = b_{eq} \\
A_{ie} \cdot c \le b_{ie} \\
c_j \in \Omega_j \tag{6}
$$
**注意**

之所以要将多项式的轨迹形式转换成贝赛尔曲线的形式，是因为贝塞尔曲线具有如下一些性质：

- 贝塞尔曲线的起点和终点总是在控制点上，并且中间点不会经过控制点；
- 贝塞尔曲线具有凸包性质(Convex hull)，根据控制点生成的曲线一定就会在控制点组成的集合之内；
- Hodograph性质。贝塞尔曲线的导数还是一个贝塞尔曲线。
- 贝塞尔曲线的时间是固定的，总是0~1.

那么，当我们用上贝塞尔曲线之后，只需要限制其控制点在约束条件之内， 最终生成的轨迹就一定满足约束条件。如果要对位置进行限制，那么就限制一段轨迹之内的所有控制点都在一个范围之内。类似的如果要限制速度、加速度等，只需要将求导之后的贝塞尔曲线的控制点进行限制即可。

## 3. Soft-constrained Optimization

对于基于贝塞尔曲线的硬约束，看起来它已经很好了，但是实际上它还存在一些小的问题可以优化，想象一下如果得到的曲线特别靠近障碍物，那么也是会满足轨迹约束的，但是此时明显就是很不安全的，当然也可以缩小飞行走廊。对于这种情况软约束就非常有效了，软约束的核心是使得生成的轨迹尽量原理障碍物。

软约束的代价函数表示如下（以多项式轨迹为例子）：
$$
J= J_s + J_c + J_d = \lambda_1 J_1 + \lambda_2 J_2 + \lambda_3 J_3 \tag 7
$$
其中：

- $J_s$是轨迹平滑性的代价，也就是之前所说的二项式代价；
- $J_c$是障碍物代价；$J_d$是动力学代价。

很明显（7）式将不再会满足凸函数的性质了，此时对于这种代价函数的优化，就必须采用更为一般的非线性优化。类似与第五节将多项式系数转换成运动状态量。那么只需要将（7）式对状态量进行求导，即可执行后续的优化了。

> 对于公式的具体细节参考PPT

## 4. Planning strategy

**a. 在实际的应用场景中，应该如何组合使用轨迹搜索和轨迹优化呢？**

- 首先，前端找到一个全局的轨迹；
- 基于传感器的检测范围和前端已经找到的轨迹，找到一个局部路径，然后得到优化的轨迹。如果轨迹之中没有障碍物那么直接执行；如果估计中出现了障碍物，那么此时就局部重新搜索生成轨迹。
- 而对于轨迹的规划一般不会高频的执行，应该等待轨迹执行一段时间之后，再执行轨迹规划。

**b. 基于探索的搜索**

如果传感器噪声严重，可能导致传感范围内没有可行轨迹，那么此时就应该控制机器人进行左右探索。

**c. 轨迹优化时如何选取初值？**

如果选择minimum snap生成的轨迹，那么光滑性很好，但是不一定会安全。而基于搜索得到的轨迹光滑性较差，但是安全性更高。

**d. 对于轨迹优化的策略**

可以先优化$J_c$使得整条轨迹是原理障碍物的。然后再对整个$J$进行整体优化。
